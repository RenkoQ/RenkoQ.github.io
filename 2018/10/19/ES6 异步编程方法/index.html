<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    
    <title>ES6 异步编程方法 | Renko&#39;s blog | 人生如逆旅，我亦是行人</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="前端">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.1.2">
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":true,"app_id":"BG0bK4DLNxackBrBBd7M3TOI-gzGzoHsz","app_key":"ji1U1fUbF7iiD8xufT3rvonA","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"BG0bK4DLNxackBrBBd7M3TOI-gzGzoHsz","appkey":"ji1U1fUbF7iiD8xufT3rvonA","notify":false,"verify":true,"placeholder":"欢迎留言...","avatar":"wavatar"}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Renko</h5>
          <a href="mailto:fqx2@outlook.com" title="fqx2@outlook.com" class="mail">fqx2@outlook.com</a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/RenkoQ" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friend"  >
                <i class="icon icon-lg icon-group"></i>
                友链
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://sunnyfu.cn"  >
                <i class="icon icon-lg icon-anchor"></i>
                简历
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>ES6 异步编程方法</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header" style="background-image: url(img/banner.jpg)">
    <div class="container fade-scale">
        <h1 class="title">ES6 异步编程方法</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-10-19T02:16:29.000Z" itemprop="datePublished" class="page-time">
  2018-10-19
</time>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-ES6 异步编程方法"
  class="post-article article-type-post fade" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">ES6 异步编程方法</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-10-19 10:16:29" datetime="2018-10-19T02:16:29.000Z"  itemprop="datePublished">2018-10-19</time>

            


            
	<span id="/2018/10/19/ES6 异步编程方法/" class="leancloud_visitors" data-flag-title="ES6 异步编程方法" title="ES6 异步编程方法">
		
			<i class="icon icon-eye"></i>
		
		<span class="leancloud-visitors-count"></span>
	</span>
 

            
    <span>
        <i class="icon icon-comment-o"></i>
        <a href="/2018/10/19/ES6 异步编程方法/#comment">
            <span class="valine-comment-count" data-xid="/2018/10/19/ES6 异步编程方法/"></span>
        </a>
    </span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>大部分复制整理于以下四篇文章，侵删致歉。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">Generator函数的含义与用法</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">Thunk函数的含义与用法</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="noopener">co函数库的含义与用法</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async函数的含义与用法</a></p>
<h3 id="协程coroutine"><a href="#协程coroutine" class="headerlink" title="协程coroutine"></a>协程coroutine</h3><pre><code>多个线程互相协作，完成异步任务。
</code></pre><ol>
<li>协程A开始执行。</li>
<li>协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li>（一段时间后）协程B交还执行权。</li>
<li>协程A恢复执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function asnycJob() &#123;</span><br><span class="line">  // ...其他代码</span><br><span class="line">  var f = yield readFile(fileA);</span><br><span class="line">  // ...其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的函数 <code>asyncJob</code> 是一个协程。<br><code>yield</code> 命令表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p>
<p>协程遇到 <code>yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<a id="more"></a>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><pre><code>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* gen(x)&#123;</span><br><span class="line">  var y = yield x + 2;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">//执行方法</span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next() // &#123; value: 3, done: false &#125;</span><br><span class="line">g.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>Generator 函数不同于普通函数，是可以暂停执行的，所以函数名之前要加<strong>星号</strong>，以示区别。</p>
<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 <code>yield</code> 语句注明。</p>
<p>调用 Generator 函数，会返回一个<code>内部指针（即遍历器 ）g</code> 。</p>
<p>调用指针 <code>g</code> 的 <code>next</code> 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 <code>yield</code> 语句，上例是执行到 <code>x + 2</code> 为止。</p>
<p>换言之，<code>next</code> 方法的作用是分阶段执行 Generator 函数。每次调用 <code>next</code>方法，会返回一个对象，表示当前阶段的信息（ <code>value 属性和 done 属性</code>）。</p>
<p><strong><code>value</code> 属性是 <code>yield</code> 语句后面表达式的值</strong>，表示当前阶段的值；<code>done</code> 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* gen(x)&#123;</span><br><span class="line">  var y = yield x + 2;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next() // &#123; value: 3, done: false &#125;</span><br><span class="line">g.next(2) // &#123; value: 2, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>第一个 <code>next</code> 方法的 value 属性，返回表达式 <code>x + 2</code> 的值<code>（3）</code>。</p>
<p>第二个 <code>next</code> 方法带有参数<code>2</code>，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果(即<code>yield</code> 语句后面表达式的值)，被函数体内的变量 <code>y</code> 接收。因此，这一步的 value 属性，返回的就是<code>2（变量 y 的值）</code>。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>捕获函数体外错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* gen(x)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var y = yield x + 2;</span><br><span class="line">  &#125; catch (e)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（&apos;出错了&apos;）;</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，Generator 函数体外，使用指针对象的 <code>throw</code> 方法抛出的错误，可以被函数体内的 <code>try ... catch</code> 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require(&apos;node-fetch&apos;);</span><br><span class="line"></span><br><span class="line">function* gen()&#123;</span><br><span class="line">  var url = &apos;https://api.github.com/users/github&apos;;</span><br><span class="line">  var result = yield fetch(url);</span><br><span class="line">  console.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">//执行函数</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line"></span><br><span class="line">//Fetch 模块返回的是一个 Promise 对象，要用 then 方法调用下一个next 方法</span><br><span class="line">result.value.then(function(data)&#123;</span><br><span class="line">  return data.json();</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Thunk"><a href="#Thunk" class="headerlink" title="Thunk"></a>Thunk</h3><p><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">Thunk 函数的含义和用法</a></p>
<h4 id="1-传值策略"><a href="#1-传值策略" class="headerlink" title="1. 传值策略"></a>1. 传值策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line">function f(m)&#123;</span><br><span class="line">  return m * 2;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + 5)</span><br></pre></td></tr></table></figure>
<p>“传值调用”（call by value）: <code>f(x + 5)即f(6)</code><br>“传名调用”（call by name）: <code>f(x + 5)即(x + 5) * 2</code></p>
<h4 id="2-Thunk函数"><a href="#2-Thunk函数" class="headerlink" title="2. Thunk函数"></a>2. Thunk函数</h4><p>Thunk 函数是<code>传名调用</code>的一种实现策略，用来替换某个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function f(m)&#123;</span><br><span class="line">  return m * 2;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + 5);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var thunk = function () &#123;</span><br><span class="line">  return x + 5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f(thunk)&#123;</span><br><span class="line">  return thunk() * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Thunk-函数（JavaScript）"><a href="#3-Thunk-函数（JavaScript）" class="headerlink" title="3. Thunk 函数（JavaScript）"></a>3. Thunk 函数（JavaScript）</h4><p>在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是<strong>多参数函数，将其替换成单参数的版本</strong>，且只接受<strong>回调函数作为参数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line">var Thunk = function (fileName)&#123;</span><br><span class="line">  return function (callback)&#123;</span><br><span class="line">    return fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Thunk-函数转换器"><a href="#Thunk-函数转换器" class="headerlink" title="Thunk 函数转换器"></a>Thunk 函数转换器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Thunk = function(fn)&#123;</span><br><span class="line">  return function ()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return function (callback)&#123;</span><br><span class="line">      args.push(callback);</span><br><span class="line">      return fn.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// fs.readFile 的 Thunk 函数</span><br><span class="line">var readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure>
<h4 id="4-Array-prototype-slice-call-arguments"><a href="#4-Array-prototype-slice-call-arguments" class="headerlink" title="4. Array.prototype.slice.call(arguments)"></a>4. Array.prototype.slice.call(arguments)</h4><p><code>arrayObj.slice(start, [end])</code>:<br>截取数组的一部分<br><code>call([thisObj[,arg1[arg2[[argN]]]]])</code>:<br>thisObj是一个对象的方法<br>arrg1~argN是参数</p>
<p>所以该方法用来<strong>把调用方法的参数截取出来</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a,b,c,d)</span><br><span class="line">  &#123;</span><br><span class="line">     var arg = Array.prototype.slice.call(arguments,1);</span><br><span class="line">     //约等于 arguments.slice(1)</span><br><span class="line">     alert(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); //b,c,d</span><br></pre></td></tr></table></figure>
<p>因为arguments并不是真正的数组对象而是Object，只是与数组类似而已，所以它并没有<code>slice</code>这个方法，而<code>Array.prototype.slice.call(arguments, 1)</code>可以理解成是让arguments转换成一个数组对象，让arguments具有<code>slice()</code>方法。要是直接写<code>arguments.slice(1)</code>会报错。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>`Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;length:2,0:&apos;first&apos;,1:&apos;second&apos;&#125;;</span><br><span class="line">//类数组,有length属性，长度为2，第0个是first，第1个是second</span><br><span class="line">console.log(Array.prototype.slice.call(a,0));</span><br><span class="line">// [&quot;first&quot;, &quot;second&quot;],调用数组的slice(0);</span><br><span class="line"></span><br><span class="line">var a=&#123;length:2,0:&apos;first&apos;,1:&apos;second&apos;&#125;;</span><br><span class="line">console.log(Array.prototype.slice.call(a,1));</span><br><span class="line">//[&quot;second&quot;]，调用数组的slice(1);</span><br><span class="line"></span><br><span class="line">var a=&#123;0:&apos;first&apos;,1:&apos;second&apos;&#125;;</span><br><span class="line">//去掉length属性，返回一个空数组</span><br><span class="line">console.log(Array.prototype.slice.call(a,0));</span><br><span class="line">//[]</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(Array.prototype.slice.call(arguments,0));</span><br><span class="line">  //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]，slice(0)</span><br><span class="line">  console.log(Array.prototype.slice.call(arguments,1));</span><br><span class="line">  //[&quot;b&quot;, &quot;c&quot;],slice(1)</span><br><span class="line">&#125;</span><br><span class="line">test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="将函数的实际参数转换成数组的方法"><a href="#将函数的实际参数转换成数组的方法" class="headerlink" title="将函数的实际参数转换成数组的方法"></a>将函数的实际参数转换成数组的方法</h5><ol>
<li><code>var args = Array.prototype.slice.call(arguments);</code></li>
<li><code>var args = [].slice.call(arguments, 0);</code></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var args = [];</span><br><span class="line">for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    args.push(arguments[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="5-Thunkify"><a href="#5-Thunkify" class="headerlink" title="5. Thunkify"></a>5. Thunkify</h4><p><a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener">https://github.com/tj/node-thunkify</a></p>
<pre><code>Turn a regular node function into one which returns a thunk, useful for generator-based flow control such as co.
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var read = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">read(&apos;package.json&apos;, &apos;utf8&apos;)(function(err, str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="6-基于-Thunk-函数的-Generator-执行器"><a href="#6-基于-Thunk-函数的-Generator-执行器" class="headerlink" title="6. 基于 Thunk 函数的 Generator 执行器"></a>6. 基于 Thunk 函数的 Generator 执行器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  function next(err, data) &#123;</span><br><span class="line">    var result = gen.next(data);</span><br><span class="line">    if (result.done) return;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">  var f1 = yield readFile(&apos;fileA&apos;);</span><br><span class="line">  var f2 = yield readFile(&apos;fileB&apos;);</span><br><span class="line">  // ...</span><br><span class="line">  var fn = yield readFile(&apos;fileN&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>run</code> 函数，就是一个 Generator 函数的自动执行器。<br>内部的 <code>next</code> 函数就是 Thunk 的回调函数。<br><code>next</code> 函数先将指针移到 Generator 函数的下一步（<code>gen.next 方法</code>），然后判断 Generator 函数是否结束（<code>result.done 属性</code>），如果没结束，就将 <code>next</code> 函数再传入 Thunk 函数（<code>result.value 属性</code>），否则就直接退出。</p>
<p>函数<code>gen</code> 封装了 n 个异步的读取文件操作，只要执行 <code>run</code> 函数，这些操作就会自动完成。</p>
<h3 id="CO"><a href="#CO" class="headerlink" title="CO"></a>CO</h3><p><a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a></p>
<pre><code>The ultimate generator based flow-control goodness for nodejs (supports thunks, promises, etc)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Generator 函数</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Generator 函数只要传入 co 函数，就会自动执行</span><br><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line">co(gen);</span><br><span class="line"></span><br><span class="line">//co 函数返回一个 Promise 对象</span><br><span class="line">co(gen).then(function ()&#123;</span><br><span class="line">  console.log(&apos;Generator 函数执行完成&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//只使用回调函数</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">function readFile(path, cb) &#123;</span><br><span class="line">  fs.readFile(path, &#123;encoding: &apos;utf8&apos;&#125;, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile(&apos;a.js&apos;, function (err, dataA) &#123;</span><br><span class="line">  console.log(dataA);</span><br><span class="line">  readFile(&apos;b.js&apos;, function (err, dataB) &#123;</span><br><span class="line">    console.log(dataB);</span><br><span class="line">    readFile(&apos;c.js&apos;, function (err, dataC) &#123;</span><br><span class="line">      console.log(dataC);</span><br><span class="line">      ...</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">//使用CO</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line"></span><br><span class="line">function readFile(path) &#123;</span><br><span class="line">  return function (cb) &#123;</span><br><span class="line">    fs.readFile(path, &#123;encoding: &apos;utf8&apos;&#125;, cb);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(function* () &#123;</span><br><span class="line">  var dataA = yield readFile(&apos;a.js&apos;);</span><br><span class="line">  console.log(dataA);</span><br><span class="line">  var dataB = yield readFile(&apos;b.js&apos;);</span><br><span class="line">  console.log(dataB);</span><br><span class="line">  var dataC = yield readFile(&apos;c.js&apos;);</span><br><span class="line">  console.log(dataC);</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>co 将所有 <code>yield</code> 后面的表达式都封装成了 <strong>Promise 对象</strong>（本身也返回一个Promise 对象），只有当前表达式执行结束后（即调用 <code>.then</code>），然后会在 <code>onFulfilled</code> 函数内执行 <code>gen.next(res)</code> 将 res 赋值给 <code>yield</code> 左侧的变量并执行到下一个 <code>yield</code>，下一个表达式执行结束后又调用 <code>gen.next()</code>，如此循环，直至 done 变为 true。</p>
<p>ES6 中的 <code>yield</code> 后面可以跟任意类型的值，但 co 对此做了限制，只允许 <code>yield</code> 后跟 <code>thunk</code>, <code>promise</code>, <code>generator</code>, <code>generatorFunction</code>,<code>array</code> 或者 <code>object</code>。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>co 函数库其实就是将两种自动执行器（<code>Thunk 函数</code>和 <code>Promise 对象</code>），包装成一个库。</p>
<ol>
<li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</li>
</ol>
<p>使用 co 的前提条件是，Generator 函数的 <code>yield</code> 命令后面，只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象。    </p>
<p>源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//co 函数接受 Generator 函数作为参数，返回一个 Promise 对象</span><br><span class="line">function co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">    //co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen.call(ctx);</span><br><span class="line">    //如果不是就返回，并将 Promise 对象的状态改为 resolved</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen);</span><br><span class="line"></span><br><span class="line">    //co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。</span><br><span class="line">    onFulfilled();</span><br><span class="line">    function onFulfilled(res) &#123;</span><br><span class="line">      var ret;</span><br><span class="line">      try &#123;</span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        return reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function next(ret) &#123;</span><br><span class="line"></span><br><span class="line">  //检查当前是否为 Generator 函数的最后一步，如果是就返回</span><br><span class="line">  if (ret.done) return resolve(ret.value);</span><br><span class="line">  //确保每一步的返回值，是 Promise 对象</span><br><span class="line">  var value = toPromise.call(ctx, ret.value);</span><br><span class="line">  //使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数</span><br><span class="line">  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);</span><br><span class="line">  //在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行</span><br><span class="line">  return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos;</span><br><span class="line">        + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>把并发的操作都放在<strong>数组或对象</strong>里面, co允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数组的写法</span><br><span class="line">co(function* () &#123;</span><br><span class="line">  var res = yield [</span><br><span class="line">    Promise.resolve(1),</span><br><span class="line">    Promise.resolve(2)</span><br><span class="line">  ];</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line">// 对象的写法</span><br><span class="line">co(function* () &#123;</span><br><span class="line">  var res = yield &#123;</span><br><span class="line">    1: Promise.resolve(1),</span><br><span class="line">    2: Promise.resolve(2),</span><br><span class="line">  &#125;;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><pre><code>async 函数就是 Generator 函数的语法糖
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">var readFile = function (fileName)&#123;</span><br><span class="line">  return new Promise(function (resolve, reject)&#123;</span><br><span class="line">    fs.readFile(fileName, function(error, data)&#123;</span><br><span class="line">      if (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">//async</span><br><span class="line">var asyncReadFile = async function ()&#123;</span><br><span class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>async 函数就是将 Generator 函数的星号（<code>*</code>）替换成 <code>async</code>，将 <code>yield</code> 替换成 <code>await</code>。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>（1）内置执行器。<br>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code>var result = asyncReadFile();
</code></pre><p>（2）更好的语义。<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。<br>co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">// 等同于</span><br><span class="line">function fn(args)&#123;</span><br><span class="line">  return spawn(function*() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//spawn 函数就是自动执行器</span><br><span class="line">function spawn(genF) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    var gen = genF();</span><br><span class="line">    function step(nextF) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        var next = nextF();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        return reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      if(next.done) &#123;</span><br><span class="line">        return resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).then(function(v) &#123;</span><br><span class="line">        step(function() &#123; return gen.next(v); &#125;);      </span><br><span class="line">      &#125;, function(e) &#123;</span><br><span class="line">        step(function() &#123; return gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(function() &#123; return gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>同 Generator 函数一样，async 函数返回一个 Promise 对象，可以使用 <code>then</code> 方法添加回调函数。<br>当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function asyncPrint(value, ms) &#123;</span><br><span class="line">  await timeout(ms);</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(&apos;hello world&apos;, 50);</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">//50毫秒以后，输出&quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 <strong><code>await</code> 命令放在 <code>try...catch</code> 代码块中</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async function myFunction() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise().catch(function (err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await 命令只能用在 async 函数之中。</p>
<p>可以使用 Promise.all 方法使多个请求并发执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  let promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  let results = await Promise.all(promises);</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者使用下面的写法</span><br><span class="line"></span><br><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  let promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  let results = [];</span><br><span class="line">  for (let promise of promises) &#123;</span><br><span class="line">    results.push(await promise);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-11-23T02:25:52.079Z" itemprop="dateUpdated">2018-11-23 10:25:52</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2018/10/19/ES6 异步编程方法/" target="_blank" rel="external">https://renkoq.github.io/2018/10/19/ES6 异步编程方法/</a>
        
    </div>
    <footer>
        <a href="https://renkoq.github.io">
            <img src="/img/avatar.jpg" alt="Renko">
            Renko
        </a>
    </footer>
</blockquote>

        
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/&title=《ES6 异步编程方法》 — Renko's blog&pic=https://renkoq.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/&title=《ES6 异步编程方法》 — Renko's blog&source=大部分复制整理于以下四篇文章，侵删致歉。
Generator函数的含义与用法Thunk函数的含义与用法co函数库的含义与用法async函数的含义与用法
协..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ES6 异步编程方法》 — Renko's blog&url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/&via=https://renkoq.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            
    <div id="comment"></div>


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/10/22/go时间处理/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">go时间处理</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/10/09/Nodemailer/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Nodemailer</h4>
      </a>
    </div>
  
</nav>


    
</article>


</div>

        <footer class="footer">
    
    <div class="bottom">
        <p>
            <span>
                Renko &copy; 2016 - 2018
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/&title=《ES6 异步编程方法》 — Renko's blog&pic=https://renkoq.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/&title=《ES6 异步编程方法》 — Renko's blog&source=大部分复制整理于以下四篇文章，侵删致歉。
Generator函数的含义与用法Thunk函数的含义与用法co函数库的含义与用法async函数的含义与用法
协..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ES6 异步编程方法》 — Renko's blog&url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/&via=https://renkoq.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://renkoq.github.io/2018/10/19/ES6 异步编程方法/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aS24bMRAFQN//0hMgqywi5r2mZURkcSVY0gxrBLT7w6+veD2/V/vu88fKr7P+zNbCwMD4WMazXOsN7QBeXW3995f3xcDAuICxDqPtphPSeuv53jAwMDCS10lAzAM6BgYGxj6jTe9mYAwMDIxZEZunevuh+Y21OAYGxgcy2sHAT75+43wDAwPjQxhPudbNtSQoz8L3P3aFgYFxNGOn1fVdBynaVK/IcDEwMA5irA9D5A2v9ohGW/QWvwkGBsZBjKLt/iOHw/KwjoGBcRtjdgAib5bl128D9Dec48DAwPjvGW1Kl48KtgaN5RQAAwPjBsbsCzuDgdnjyFNSDAyM8xhtWNxPGaORZNmew8DAOJuRBM38xrOBZf5/oChoMTAwjmDMbtYmf22iWRfPGBgYFzPy1nxb6O6MCv5yfQwMjGsYs55c21bbGZoWhy0wMDAOYrTBMfnkTmGcjFQxMDDuZMyOSuQl6076mJS1GBgY9zDyAcD+FmdttWgSi4GBcRwjD6+zow/5mHPn8WFgYNzGaIeU+WAyTzHzQFxPGzAwMD6Q8b5LFzeLV3u8AwMD4wzGU65ZEdt+tx1kYmBgnM1og90sHZwxZskoBgbGqYxZkJ0NL5PtDotqDAyMCxhJkG3b+u2YYdZDw8DAwMiHkXm4XG86efdlaoiBgYER335W6M4eFgYGxj2M/SK2mJEui9489cTAwLiHsT8YaE9z5AF3dn0MDIyDGL8AR1AKPzxS9psAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.1.2"></script>

<script type="text/javascript" src="https://cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.1.2"></script>
<script type="text/javascript" src="/js/blog.js?v=1.1.2"></script>

<!-- third-party -->





<script type="text/javascript" src="/js/plugins/local_search.js?v=1.1.2"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



    
        <script type="text/javascript" src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.1.2"></script>
    



<script type="text/javascript" src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script type="text/javascript" src="/js/plugins/leancloud_visitors.js?v=1.1.2"></script>



    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    
</body>
</html>
